%% Comparing the eccentrity of several "grid" dataset measured on the iCub Robot
% This script take dataset in the "grid" format (generated by
% reachRandomJointPositions [1] module) on the iCub robot and compare 
% the eccentrity of the force measurement. In theory the "grid" movement
% is slowly (so the only thing that matters is gravity) moving the legs,
% while the robot is fixed on the pole (so the only external force are 
% on the root_link). In theory then the measured force should be equal 
% to m*g , where g \in R^3 is the gravity expressed in the sensor frame. 
% Hence the measured force should lie on a sphere (eccentrities 0,0) in
% theory. However imperfect sensor can have a different eccentricities (
% but in general they remain linear, so the sphere become an ellipsoid).
% For more on the theory behind this script, check [2].
% [1] : https://github.com/robotology/codyco-modules/tree/master/src/misc/reachRandomJointPositions
% [2] : Traversaro, Silvio, Daniele Pucci, and Francesco Nori. 
%       "In situ calibration of six-axis force-torque sensors using accelerometer measurements."
%       Robotics and Automation (ICRA), 2015 IEEE International Conference on. IEEE, 2015.

%%
%add required folders for use of functions
addpath external/quadfit
addpath utils
% name and paths of the data files

% experimentName='icub-insitu-ft-analysis-big-datasets/2016_04_21/extendedYoga4StandingOnLeft';% Name of the experiment;
  experimentName='icub-insitu-ft-analysis-big-datasets/2016_05_09/darmstadt';% Name of the experiment;
% experimentName='icub-insitu-ft-analysis-big-datasets/2016_05_12/LeftLegTsensor';% Name of the experiment;
%   experimentName='icub-insitu-ft-analysis-big-datasets/2016_05_17/slowBlack';% Name of the experiment;
%  experimentName='icub-insitu-ft-analysis-big-datasets/16_03_2016/leftRightLegsGrid';
%  experimentName='icub-insitu-ft-analysis-big-datasets/2016_04_19/blackUsingOldSensor';% Name of the experiment;
% Script options, meant to control the behavior of this script 
scriptOptions = {};
scriptOptions.forceCalculation=false;%false;
scriptOptions.printPlots=true;%true

% Script of the mat file used for save the intermediate results 
striptOptions.matFileName='datasetEllipsoidAnalys';

% load the script of parameters relative 
paramScript=strcat('data/',experimentName,'/params.m');
run(paramScript)

% This script will produce dataset (containing the raw data) and dataset2
% (contained the original data and the filtered ft). 

if (exist(strcat('data/',experimentName,'/',striptOptions.matFileName,'.mat'),'file')==2 && scriptOptions.forceCalculation==false)
    %% Load from workspace
    %     %load meaninful data, estimated data, meaninful data no offset
    load(strcat('data/',experimentName,'/',striptOptions.matFileName,'.mat'),'dataset')
    
else
    ftDataName=strcat(input.ftPortName,'/data.log'); % (arm, foot and leg have FT data)
    stateDataName=strcat(input.statePortName,'/data.log');  % (only foot has no state data)
    %params.m is expected to have contactInfo (1 right ,0 left ), relevant (if
    %there is an specific interval desired to study (1 true, 0 false ) and
    %rData which is a double array 1x2 that has begining and ending of interval in seconds
    
    
    for i=1:size(input.ftNames,1)
        dataFTDirs{i}=strcat('data/',experimentName,'/icub/',input.ftNames{i},'/',ftDataName);
        
    end
    stateNames=fieldnames(input.stateNames);
    for i=1:size(stateNames,1)
        dataStateDirs{i}=strcat('data/',experimentName,'/icub/',stateNames{i},'/',stateDataName);     
    end
    %TODO: replace "icub" for robot model? so that it can be used for other
    %robots, although this is dependent on the output kind of the data dumper
    
    
    %% load FT data
    [ftData.(input.ftNames{1}),time]=readDataDumper(dataFTDirs{1});
    nanIndex=0;
    nanCount=0;
    for i=2:size(input.ftNames,1)
        %read from dataDumper
        [ftData_temp,time_temp]=readDataDumper(dataFTDirs{i});
        %resample FT data
        ftData.(input.ftNames{i})=resampleFt(time,time_temp,ftData_temp);
        %if the initial time of the time_temp is less than time it might return
        %NaN values for the those first values, so we will take into account
        %which has the biggest amount of nans and remove those values with
        %applyMask later
        if (sum(isnan(ftData.(input.ftNames{i})(:,1)))>nanCount)
            nanIndex=i;
            nanCount=sum(isnan(ftData.(input.ftNames{i})(:,1)));
        end
    end
    
    %% load state and calculate estimated wrenches for comparison
    [dataset]=obtainEstimatedWrenches(dataStateDirs,input.stateNames,input.robotName,time,contactFrameName);
    
    dataset.time=time;
    dataset.ftData=ftData;
    
    sensorNames=fieldnames(dataset.estimatedFtData);
    
    % match field names with sensor loaded through readDataDumper
    %
    matchup=zeros(size(input.sensorNames,1),1);
    for i=1:size(input.sensorNames,1)
        matchup(i) = find(strcmp(sensorNames, input.sensorNames{i}));
    end
    
    %replace the estored estimatedFtData for one with the same order as the
    %ftData
    for i=1:size(input.ftNames,1)
        estimatedFtData.(input.ftNames{i})=dataset.estimatedFtData.(sensorNames{matchup(i)});
    end
    dataset.estimatedFtData=estimatedFtData;
    
    if (input.relevant==1)
        mask=dataset.time>dataset.time(1)+rData(1) & dataset.time<dataset.time(1)+rData(2);
        dataset=applyMask(dataset,mask);
    end
    
    %% Filter data
    % filtered ft data
    [filteredFtData,mask]=filterFtData(dataset.ftData);

    dataset=applyMask(dataset,mask);
    filterd=applyMask(filteredFtData,mask);
    dataset.filteredFtData=filterd;
    
    %% Save the workspace
    %     %save meaninful data, estimated data, meaninful data no offset
    save(strcat('data/',experimentName,'/',striptOptions.matFileName,'.mat'),'dataset')
end



%% Remove offset (to check similarity by visual inspection)

% compute the offset that minimizes the difference with 
% the estimated F/T (so if the estimates are wrong, the offset
% estimated in this way will be totally wrong) 
for i=1:size(input.ftNames,1)
    [ftDataNoOffset.(input.ftNames{i}),offsetX.(input.ftNames{i})]=removeOffset(dataset.filteredFtData.(input.ftNames{i}),dataset.estimatedFtData.(input.ftNames{i}));
end

dataset.ftDataNoOffset=ftDataNoOffset;

% We carry the analysis just for a subset of the sensors
sensorsToAnalize = {'left_leg','right_leg'};

%% Some visual inspection
if(scriptOptions.printPlots)
    
    % Plot sensor vs estimated (with offset computed the minimum distance
    % from estimated)
    figure;
    for ftIdx =1:length(sensorsToAnalize)
        ft = sensorsToAnalize{ftIdx};
        subplot(1,2,ftIdx);
        plot3_matrix(dataset.ftDataNoOffset.(ft)(:,1:3))
        hold on;
        axis equal;
        plot3_matrix(dataset.estimatedFtData.(ft)(:,1:3))
          legend('measuredData','estimatedData','Location','west');
        title(strcat({'Wrench space '},escapeUnderscores(ft)));
        xlabel('F_{x}');
        ylabel('F_{y}');
        zlabel('F_{z}');
        axis equal;
        grid on;
    end
    % subtitle('Force estimated from the model and force measured (with offset removed)');

    
    % Plot sensor vs estimated (with offset computed the minimum distance
    % from estimated)
    figure;
    for ftIdx =1:length(sensorsToAnalize)
        ft = sensorsToAnalize{ftIdx};
        subplot(2,1,ftIdx);
        plot(dataset.ftDataNoOffset.(ft)(:,1:3));
        hold on;
        plot(dataset.estimatedFtData.(ft)(:,1:3));
        title(strcat({'Data no Offset vs estimated data '},escapeUnderscores(ft)));
         legend('F_{x}','F_{y}','F_{z}','F_{x2}','F_{y2}','F_{z2}','Location','west');
       
    end
    % subtitle('Force estimated from the model and force measured (with offset removed)');

    figure;
    for ftIdx =1:length(sensorsToAnalize)
        ft = sensorsToAnalize{ftIdx};
        subplot(2,1,ftIdx);
        normOfError = normOfRows(dataset.ftDataNoOffset.(ft)(:,1:3)-dataset.estimatedFtData.(ft)(:,1:3));
        plot(normOfError);
        title(strcat({'Data no Offset - estimated data norm '},escapeUnderscores(ft)));
         legend('Norm','Location','west');
        
    end
    % subtitle('Error in norm between the force estimated from the model and the one measured (with offset removed)');
end

%% Check ellipsoid 
for ftIdx =1:length(sensorsToAnalize)
     ft = sensorsToAnalize{ftIdx};
        
     % We don't have a direct measure of the gravity acceleration in the 
     % sensor, so we use the estimate FT as a undirected measure
     fittedEllipsoid_im = ellipsoidfit_smart(dataset.ftDataNoOffset.(ft)(:,1:3),dataset.estimatedFtData.(ft)(:,1:3));
        
     % If the measure was perfect, the radius of the force measurements
     % would be exactly m*|g| ~ m*9.81 
     % We then can print the "mass" as seen by the sensor axis, by
     % computing the intersection of the ellipsoid with the x,y,z sensor 
     % axis (if the x,y,z axis of the sensor are also the principal axis
     % of the ellipsoid, this are the radii of the ellipsoid in explicit form)
     intersections = ellipsoid_intersectionWithAxis(fittedEllipsoid_im);
     g = 9.81;
     masses = intersections/g;
     fprintf('The apparent mass attached (using gravity from kinematics) at the sensor %s for axis x,y,z are (%f,%f,%f)\n',ft,masses(1),masses(2),masses(3));
     
     figure
     plot3(dataset.ftDataNoOffset.(ft)(:,1),dataset.ftDataNoOffset.(ft)(:,2),dataset.ftDataNoOffset.(ft)(:,3),'g.'); hold on;
     plot3_matrix(dataset.estimatedFtData.(ft)(:,1:3)); hold on;
     plot_ellipsoid_im(fittedEllipsoid_im);
       legend('measuredData','estimatedData','Location','west');
        title(strcat({'Wrench space '},escapeUnderscores(ft)));
        xlabel('F_{x}');
        ylabel('F_{y}');
        zlabel('F_{z}');
        axis equal;
     
     % We do the same computation, but using the best fitt that does not
     % use the data on gravity (to avoid relyng on anything)
     fittedEllipsoid_noGravity = ellipsoidfit_leastsquares(dataset.ftDataNoOffset.(ft)(:,1),dataset.ftDataNoOffset.(ft)(:,2),dataset.ftDataNoOffset.(ft)(:,3));

     intersections_noGravity = ellipsoid_intersectionWithAxis(fittedEllipsoid_noGravity);
     g = 9.81;
     masses_noGravity = intersections_noGravity/g;
     fprintf('The apparent mass attached (without using the model) at the sensor %s for axis x,y,z are (%f,%f,%f)\n',ft,masses_noGravity(1),masses_noGravity(2),masses_noGravity(3));
    
     figure
     plot3(dataset.ftDataNoOffset.(ft)(:,1),dataset.ftDataNoOffset.(ft)(:,2),dataset.ftDataNoOffset.(ft)(:,3),'b.');
     plot_ellipsoid_im(fittedEllipsoid_noGravity);
      legend('measuredData','Location','west');
        title(strcat({'Wrench space '},escapeUnderscores(ft)));
        xlabel('F_{x}');
        ylabel('F_{y}');
        zlabel('F_{z}');
        axis equal;
     
     %% We do exactly the same computation on the estimted FT data to get information on 
% the assume attached mass in the model
      % We don't have a direct measure of the gravity acceleration in the 
    % sensor, so we use the estimate FT as a undirected measure
    fittedEllipsoid_im_circular = ellipsoidfit_smart(dataset.estimatedFtData.(ft)(:,1:3),dataset.estimatedFtData.(ft)(:,1:3));
        
    % If the measure was perfect, the radius of the force measurements
    % would be exactly m*|g| ~ m*9.81 
    % We then can print the "mass" as seen by the sensor axis, by
    % computing the intersection of the ellipsoid with the x,y,z sensor 
    % axis (if the x,y,z axis of the sensor are also the principal axis
    % of the ellipsoid, this are the radii of the ellipsoid in explicit form)
    intersections_circular = ellipsoid_intersectionWithAxis(fittedEllipsoid_im_circular);
    g = 9.81;
    masses_estimated = intersections_circular/g;
    fprintf('The mass attached to the sensor %s (from the model) is (%f)\n',ft,masses_estimated(1));

    error=masses-masses_estimated;
    error_noGravity=masses_noGravity-masses_estimated;
end

